"""
Base class for action operators in GRL.

An ActionOperator transforms the current state to produce the next state.
Unlike classical RL where actions are vectors, operators are functions
that act on the state space.
"""

from abc import ABC, abstractmethod
from typing import Optional

import torch
import torch.nn as nn


class ActionOperator(nn.Module, ABC):
    """
    Abstract base class for action operators.
    
    In GRL, an action is an operator O: S -> S that transforms the state space.
    The operator is generated by a policy network conditioned on the current state.
    
    Key methods:
        forward: Apply the operator to transform a state
        energy: Compute the operator's "action energy" for least-action regularization
        
    The least-action principle encourages operators with minimal energy,
    leading to smooth, efficient state transitions.
    """
    
    def __init__(self, state_dim: int, **kwargs):
        """
        Initialize the operator.
        
        Args:
            state_dim: Dimensionality of the state space
        """
        super().__init__()
        self.state_dim = state_dim
    
    @abstractmethod
    def forward(self, state: torch.Tensor) -> torch.Tensor:
        """
        Apply the operator to transform the state.
        
        Args:
            state: Current state tensor of shape (batch_size, state_dim)
            
        Returns:
            Next state tensor of shape (batch_size, state_dim)
        """
        raise NotImplementedError
    
    @abstractmethod
    def energy(self) -> torch.Tensor:
        """
        Compute the operator's action energy.
        
        This implements the least-action principle: operators with lower
        energy are preferred, encouraging smooth and efficient transformations.
        
        Common energy functionals:
            - L2 norm of parameters (Frobenius for matrices)
            - Gradient norm for field operators
            - Spectral norm for stability
            
        Returns:
            Scalar energy tensor
        """
        raise NotImplementedError
    
    def compose(self, other: "ActionOperator") -> "ActionOperator":
        """
        Compose this operator with another: (self ∘ other)(s) = self(other(s))
        
        Args:
            other: Another ActionOperator to compose with
            
        Returns:
            A new ComposedOperator
        """
        return ComposedOperator(self, other)
    
    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(state_dim={self.state_dim})"


class ComposedOperator(ActionOperator):
    """
    Composition of two operators: (O1 ∘ O2)(s) = O1(O2(s))
    
    This enables hierarchical and compositional operator structures.
    """
    
    def __init__(self, outer: ActionOperator, inner: ActionOperator):
        """
        Initialize composed operator.
        
        Args:
            outer: The outer operator O1
            inner: The inner operator O2
        """
        assert outer.state_dim == inner.state_dim, "Operators must have matching state dimensions"
        super().__init__(state_dim=outer.state_dim)
        self.outer = outer
        self.inner = inner
    
    def forward(self, state: torch.Tensor) -> torch.Tensor:
        """Apply inner then outer: O1(O2(s))"""
        return self.outer(self.inner(state))
    
    def energy(self) -> torch.Tensor:
        """Sum of component energies."""
        return self.outer.energy() + self.inner.energy()


class IdentityOperator(ActionOperator):
    """
    Identity operator: O(s) = s
    
    The "no-op" action in GRL. Useful as a baseline and for skip connections.
    """
    
    def __init__(self, state_dim: int):
        super().__init__(state_dim=state_dim)
    
    def forward(self, state: torch.Tensor) -> torch.Tensor:
        return state
    
    def energy(self) -> torch.Tensor:
        return torch.tensor(0.0, device=next(self.parameters(), torch.zeros(1)).device)
    
    def parameters(self, recurse: bool = True):
        """Identity has no parameters."""
        return iter([])
